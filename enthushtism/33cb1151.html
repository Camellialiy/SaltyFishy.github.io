<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>查找 | 摘星崖</title><meta name="author" content="Enthushtism_"><meta name="copyright" content="Enthushtism_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍数据结构中查找的基本思想">
<meta property="og:type" content="article">
<meta property="og:title" content="查找">
<meta property="og:url" content="https://enthushtism.top/enthushtism/33cb1151.html">
<meta property="og:site_name" content="摘星崖">
<meta property="og:description" content="介绍数据结构中查找的基本思想">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://enthushtism.top/img/%E6%9F%A5%E6%89%BE.jpg">
<meta property="article:published_time" content="2023-01-06T02:19:50.000Z">
<meta property="article:modified_time" content="2023-03-15T03:35:58.024Z">
<meta property="article:author" content="Enthushtism_">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://enthushtism.top/img/%E6%9F%A5%E6%89%BE.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://enthushtism.top/enthushtism/33cb1151"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"NKSY29S9JI","apiKey":"8d4250e2ca15c28ffb5d99b4a31988c1","indexName":"Hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":"100# When will it be shown","position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '查找',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-15 11:35:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}
setTimeout(function(){preloader.endLoading();}, 5000);</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/talk/"><i class="fa-fw fas fa-coffee"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/plan/"><i class="fa-fw fas fa-paper-plane"></i><span> 待更新计划</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E6%9F%A5%E6%89%BE.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">摘星崖</a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/talk/"><i class="fa-fw fas fa-coffee"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/plan/"><i class="fa-fw fas fa-paper-plane"></i><span> 待更新计划</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">查找</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-06T02:19:50.000Z" title="发表于 2023-01-06 10:19:50">2023-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-15T03:35:58.024Z" title="更新于 2023-03-15 11:35:58">2023-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/data-structure/">data structure</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="查找"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="查找概述"><a href="#查找概述" class="headerlink" title="查找概述"></a>查找概述</h2><p><strong>查找</strong>，就是根据给定的某个值在一组记录集合中确定某个“特定的”数据元素（记录）或者找到属性值符合特定条件的某些记录。<br><strong>查找表</strong>是由同一类型的数据元素（或记录）构成的集合。<br><strong>关键字</strong>：是数据元素（或记录）中某个数据项的值，用以标识一个数据元素（或记录）。<br><strong>主关键字</strong>：可以识别标识一个记录的关键字。<br><strong>次关键字</strong>：可以识别若干记录的关键字。</p>
<p>对于一次查找，如果存在记录或数据元素，那么这次查找是成功的，否则是失败的。</p>
<p>对于查找表，一般有两类：</p>
<p><strong>1.静态查找表</strong></p>
<p>是一种只作查找操作的查找表。</p>
<p>基本操作如下：</p>
<ol>
    <li>查询某个"特定的"数据元素是否在查找表中。</li>
    <li>检索某个特定的数据元索和各种属性</li>
</ol>


<p><strong>2.动态查找表</strong></p>
<p>在查找过程中同时插入查找表中不存在的数据元素或者从查找表中删除已经存在的某个数据元素。</p>
<p>基本操作如下：</p>
<ol>
    <li>查找时插入数据元素。</li>
    <li>查找时删除数据元素</li>
</ol>


<p>需要注意的是，通常我们提到查找，通常都是查找某个数据元素是否存在或者查看它的属性，但是在当前的这一章中，查找就不只是这么简单了，他还包括对数据集合进行修改的操作。</p>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>顺序查找（线性查找），是最基本的查找技术，它的查找过程是:从表中第一个(或最后一个)记录开始 ，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，返回找到所查的记录;如果直到最 后一个(或第1个)记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</p>
<p>其实就是很简单的遍历过程:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Seq_Search</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++){</span><br><span class="line">        <span class="keyword">if</span> (a[i] == key){</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查找失败</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里注意到每次我们都进行了i和n的比较，而实际上我们可以对它进行优化，实际操作就是定义一个哨兵:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Seq_Search</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span>{</span><br><span class="line">    <span class="type">int</span> i = n;</span><br><span class="line">    a[<span class="number">0</span>] = key;<span class="comment">//将a[0]置为哨兵</span></span><br><span class="line">    <span class="keyword">while</span>(a[i] != key){</span><br><span class="line">        i--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;<span class="comment">//查找失败</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种方法免去了每次执行i与n的判断，在有较大的总数据时可以提高一定的效率。</p>
<p>无论是优化过还是优化前，顺序查找的复杂度均为O(n)</p>
<h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><p>前面的顺序查找虽然很简单，但是缺点也很明显，当数据量过大的时候，我们很难在很短的时间内得到一个比较好的结果。这是因为我们需要查找的数据他在数据集合中的位置是随机的，由此我们产生一个思考：是否我们可以按照一定的顺序，对数据集合先进行排列，然后再进行查找？显然是可以的。</p>
<h4 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h4><p>折半查找，又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大有序) ，线性表必须采用顺序存储。折半查找的基本思想是:在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相 等，则查找成功;若给定值小于中间记录的关键字，则在中间记录的左半区继续查找，若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span>{</span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>,high = n,mid = (<span class="number">1</span> + n) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high){</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; key){</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; key){</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于每次我们都取1/2的数据集进行查找，所以最坏的查找次数显然是log2n+1，最好显然是1，总的时间复杂度为O(logn)</p>
<p>但是由于折半查找要求数据集合必须有序，并且是顺序存储方式，并且一旦排序后其顺序不变，所以显然这种查找方式只适合静态查找表。</p>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><p>现在我们引申出了一个新的问题：为什么我们每次都只进行二分呢？比如我们如果在牛津字典里查找apple，你会从词典的中间开始吗？显然不会，你会从字典前面部分开始。插值查找，做的就是对这一个部分的优化。</p>
<p>具体的操作就是将折半查找的 $mid = \frac{low + high}{2}$ 做转换</p>
<script type="math/tex; mode=display">
mid = \frac{low + high}{2} = low + \frac{high - low}{2} = low + \frac{(key - a[low]) * (high - low)}{a[high] - a[low]}</script><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Insert_Search</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span>{</span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>,high = n,mid = (<span class="number">1</span> + n) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high){</span><br><span class="line">        mid = low + (key - a[low]) * (high - low)/ (a[high] - a[low]);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; key){</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; key){</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>插值查找对于均匀分布的数据集合相当有利，效率也远高于原本的二分查找，但是如果数据集合的分布不够均匀，那儿么他的性能就大打折扣了。</p>
<h4 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h4><p>这种查找方式要求我们首先已经求得了一个斐波那契数列。</p>
<p>斐波那契查找算法的核心在于三点：</p>
<ol>
    <li>当key = a[mid]，查找成功</li>
    <li>当key小于a[mid]，说明需要查找的数据元素在左侧，那么新的范围就应该从low到mid-1，其中有F[k]-1个元素</li>
    <li>当key大于a[mid]，说明需要查找的元素在右侧，那么新的范围就应该从mid+1到high，其中有F[k-2]-1个元素</li>
</ol>


<p><img src="https://img-blog.csdnimg.cn/a988dae50b3445beb89103280817d31e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span>{</span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>,high = n,mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>,i = n;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; F[k] - <span class="number">1</span>){<span class="comment">//计算n位于斐波那契数列的位置</span></span><br><span class="line">        k++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (;i &lt; F[k] - <span class="number">1</span>;i++){<span class="comment">//补充数列使整个数列有序</span></span><br><span class="line">        a[i] = a[n];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high){</span><br><span class="line">        mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]){</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            k -= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid]){</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            k -= <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (mid &lt;= n){</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见，如果查找的数据都位于分割点左侧，那么斐波那契查找的效率远大于折半查找，但是如果位于右侧，那么就会远低于折半查找，尽管他们的复杂度均为O(logn)</p>
<h4 id="有序表查找小总结"><a href="#有序表查找小总结" class="headerlink" title="有序表查找小总结"></a>有序表查找小总结</h4><p>可以发现，三种有序表查找，实际上思想都是对一组有序数据集合进行分割，只是他们分割的点不同。</p>
<p>折半查找的分割点为 $mid = \frac{low + high}{2}$</p>
<p>插值查找的分割点为 $mid = low + \frac{(high - low) * (key - a[low])}{a[high] - a[low]} $</p>
<p>斐波那契查找的分割点为 $mid = low + F[k - 1] - 1$</p>
<p>这三种分割点的运算由于执行的分割点的计算（加减与数乘）可能会存在微小的效率差别，使用时需要具体分析。</p>
<h3 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h3><p>前面的查找算法都是基于数据集合已经有序的前提下，但是很多数据集合的元素个数可能增长得很快，如果每次更新我们都要保障他们有序那么无疑是非常浪费时间和资源的。</p>
<p>对于按照<strong>时间先后顺序</strong>存储的查找表，我们通过<strong>索引</strong>的方式来查找。</p>
<p><strong>索引，类似我们学的数组，实际上就是将关键字与他的对应的记录相关联的过程。</strong></p>
<p><strong>对于线性索引，就是将索引项集合组织为线性结构。</strong></p>
<p>下面是三种线性索引：</p>
<h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h4><p><strong>稠密索引是指在线性索引中 ，将数据集中的每个记录对应一个索引项。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/1b8960ce5b1440fa971e96ca124949fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_19,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</p>
<p>索引项有序意味着查找关键字时我们可以用折半查找、、插值查找、斐波那契查找的方法来提高效率。</p>
<p>但是他也有类似的问题，如果数据集合非常大，那么意味着索引表也会非常长，就会使得查找的性能下降。</p>
<h4 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h4><p>分块索引，是建立了一种类似图书馆的存储结构。</p>
<p>对于稠密索引来说，因为索引项与数据集合的个数相同，所以空间代价非常大。为了减少这种代价，我们可以<strong>对数据集合进行分块，再对分块有序，然后建立每一个块的索引项，从而减少索引项的个数。</strong></p>
<p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p>
<p> 1.<strong>块内无序</strong>，即每一块内的记录不要求有序。</p>
<p> 2.<strong>块间有序</strong>，例如，要求第2块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键 字……因为只有块间有序，才有可能在查找时带来放率。</p>
<p>一般来说，分块索引的索引项结构分三个数据项：</p>
<p>1.<strong>最大关键码</strong>，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这块最大的关键字要大</p>
<p>2.存储了<strong>块中的记录个数</strong>，以便于循环时使用;</p>
<p>3.用于<strong>指向块首数据元素的指针</strong>，便于开始对这一块中记录进行遍历。</p>
<p><img src="https://img-blog.csdnimg.cn/73d2252aaa5142879e3dff0a2c6d7bbc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_18,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>在分块索引表中查找分为两步:</p>
<p>1.在分块索引表中查找要查关键字所在的块。因为分块索引表示有序的，所以可以使用折半查找、插值查找和斐波那契查找的算法。</p>
<p>2.在对应的块中顺序查找。</p>
<p>由于索引表是有序的，所以分块查找的效率比之顺序查找是要高的，但是却与O(logn)的查找存在不小的差距。</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>倒排索引，与搜索引擎有着密切的关系。</p>
<p>比如现在数据库中有两个句子，标号为1,2：</p>
<p><img src="https://img-blog.csdnimg.cn/6129531d268c4798afb71bf87b1083bf.png" referrerpolicy="no-referrer"></p>
<p>如果我们忽略掉单词的大小写、复数s等，可以得到如下单词表:</p>
<p><img src="https://img-blog.csdnimg.cn/a64e01f9aeb74cc49e3edd02bb5ff127.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_9,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>这样，每当我们检索某个单词的时候，我们只需要查找单词表，然后返回对应的编号的文章地址就好了。</p>
<p>在这里这张单词表就是索引表，索引项的通用结构是:</p>
<p>1.<strong>次关键码</strong>，例如上面的”英文单词 “</p>
<p>2.<strong>记录号表</strong>，例如上面的”文章编号“</p>
<p><strong>其中记录号表存储具有相同次关键字的所有记录的记录号，可以是指向记录的指针或者是该记录的主关键字，这样的索引方法就是倒排索引。</strong></p>
<h4 id="二叉排序树（二叉搜索树）"><a href="#二叉排序树（二叉搜索树）" class="headerlink" title="二叉排序树（二叉搜索树）"></a>二叉排序树（二叉搜索树）</h4><p>前面我们所讲的查找方式基本上都是基于静态查找表的思想：查找的时候只执行查找，而不包括插入与删除操作。并且前面的查找方法都要求数据集合有序、顺序存储等，这就给插入与删除操作带来了极大的不便。</p>
<p>前面我们又提到了动态查找表的思想，而二叉排序树就是一个动态查找表，它具有良好的插入与删除效率，并且在查找方面的效率也不低。</p>
<p>从最简单的情况开始考虑：我们现在有第一个数字12，于是我们把它加入数据集合，接下来我有第二个数80，按照有序的关系，此时集合为{12,80}然后当我们加入第三个数7时，这时候发现7同时小于12和80，如果我们按照前面的思想，我们就需要移动12和80元素的位置，然后再把7加入集合。但是我们不妨换一个思路，利用二叉树的性质，我们先把12作为根节点，然后因为80大于12，把80作为12的右孩子，又因为7小于12，把7作为12的左孩子，于是我们得到了这样一个二叉树，并且根据二叉树的关系，他保存了7,12和80之间的大小排序关系：</p>
<p><img src="https://img-blog.csdnimg.cn/36ad1c6b89f0423aae3b6790fd7ac56e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_16,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>这样的话，我们就可以归纳出这种思想的核心：<strong>如果我们要对一个集合进行查找，我们就必须在创建该集合时就采用二叉树结构，并且该二叉树必须有序</strong>，如我们对集合{62. 88.58.47 35.73.51. 99 .37 .93}做查找，我们就需要创建如图所示的二叉树：</p>
<p><img src="https://img-blog.csdnimg.cn/7dea6824f2a140749b4d5dfdd83d939e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_14,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>当我们对该二叉树进行<strong>中序遍历</strong>，我们就能得到一个有序的序列：{35.37，47.51 58 62 73，88，93.99}</p>
<p>这样的结构我们称为<strong>二叉排序树</strong></p>
<p><strong>二叉排序树，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树：</strong></p>
<ol>
    <li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值</li>
    <li>若它的右子树不空 ，则右子树上所有结点的值均大于宫的根结点的值</li>
    <li>它的左、右子树也分别为二叉排序树</li>
</ol>


<p>下面的代码给出了二叉排序树的<strong>搜索</strong>算法:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SearchBST</span><span class="params">(BiSearchTree T,<span class="type">int</span> key,BiSearchTree parent,BiSearchTree* p)</span> </span>{<span class="comment">//p为返回的结点</span></span><br><span class="line">	<span class="keyword">if</span> (!T) {<span class="comment">//不存在该结点则返回上一级结点</span></span><br><span class="line">		*p = parent;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data) {</span><br><span class="line">		*p = T;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data) {</span><br><span class="line">		<span class="built_in">SearchBST</span>(T-&gt;lchild, key, T, p);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; T-&gt;data) {</span><br><span class="line">		<span class="built_in">SearchBST</span>(T-&gt;rchild, key, T, p);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意调用时格式第三个参数必须为NULL，如:SearchBST(*T,0,NULL,p)</strong></p>
<p>它的作用在这里不明显，但是在插入算法中就很明显了</p>
<p>类似的，可以给出二叉排序树的<strong>插入</strong>算法:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertBST</span><span class="params">(BiSearchTree* T, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">	BiSearchTree p,temp;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">SearchBST</span>(*T, key, <span class="literal">NULL</span>, &amp;p)) {<span class="comment">//不存在同值结点，插入</span></span><br><span class="line">		temp = <span class="keyword">new</span> BiSearchTNode;</span><br><span class="line">        temp-&gt;data = key;</span><br><span class="line">		temp-&gt;lchild = temp-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (!p) { <span class="comment">//空树</span></span><br><span class="line">			T = &amp;p;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; p-&gt;data) {<span class="comment">//小于，插入左子树</span></span><br><span class="line">			p-&gt;lchild = temp;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; p-&gt;data) {</span><br><span class="line">			p-&gt;rchild = temp;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//存在同值结点，插入失败</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里可以看出，这个parent指针的作用了，他保存了最后一次遍历的时候的位置，方便我们定位插入数据的位置。</p>
<p>但是，对于<strong>删除</strong>操作，则没那么容易了，因为删除操作如果只是简单的删除某个节点，可能会导致数据的缺失，可能会导致顺序的破坏。我们分类讨论:</p>
<ol>
    <li>对于叶子结点，显然直接删除即可，因为删除他们不影响顺序</li>
    <li>如果要被删除的结点只有左子树或只有右子树，那么也很好解决，只要删除该结点前保留其左右子树，然后“子承父业”即可</li>
    <li>但是如果要被删除的结点左右子树均有，那就麻烦了，这时候我们采取另外一种思想，在被删除的结点的左右子树中寻找能够替代该结点的结点（也就是中序遍历该二叉树中要被删除结点的直接前驱或直接后继），然后把他作为要被删除结点的代替结点加入。</li>
</ol>


<p>实现代码如下:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(BiSearchTree* T)</span> </span>{</span><br><span class="line">	BiSearchTree temp = *T,p;</span><br><span class="line">	<span class="keyword">if</span> ((*T)-&gt;rchild == <span class="literal">NULL</span>) {</span><br><span class="line">		*T = (*T)-&gt;lchild;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((*T)-&gt;lchild == <span class="literal">NULL</span>) {</span><br><span class="line">		*T = (*T)-&gt;rchild;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {<span class="comment">//左右子树均不空</span></span><br><span class="line">		p = (*T)-&gt;lchild;<span class="comment">//找直接前驱方法,从被删除结点的左子树的根节点开始，不断往右子树探</span></span><br><span class="line">		<span class="keyword">while</span> (p-&gt;rchild) {</span><br><span class="line">			temp = p;<span class="comment">//此处temp为要被添加的直接前驱的父结点，用于补完二叉树</span></span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		}</span><br><span class="line">		(*T)-&gt;data = p-&gt;data;</span><br><span class="line">		<span class="keyword">if</span> (temp != *T) {<span class="comment">//接上右子树</span></span><br><span class="line">			temp-&gt;rchild = p-&gt;lchild;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {<span class="comment">//如果temp等于*T,说明temp-&gt;data就是直接前驱，直接接上即可</span></span><br><span class="line">			temp-&gt;lchild = p-&gt;lchild;<span class="comment">//等价于temp-&gt;lchild = temp-&gt;lchild-&gt;lchild;</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteBST</span><span class="params">(BiSearchTree* T, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (!T) {<span class="comment">//不存在key值相等的元素或者为空树</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">if</span> (key == (*T)-&gt;data) {<span class="comment">//找到就删除</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Delete</span>(T);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; (*T)-&gt;data) {</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">DeleteBST</span>(&amp;(*T)-&gt;lchild, key);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; (*T)-&gt;data) {</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">DeleteBST</span>(&amp;(*T)-&gt;rchild, key);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二叉排序树作为一种用二叉树的存储结构的排序集合，保持了存储结构不需要移动结点就能够实现插入和删除的优点，而当我们查找的时候，只需要顺着二叉树查找即可，查找最多也不会超过树的深度。这样看起来已经足够优秀了，但是它仍存在一些问题，因为与深度有关，所以二叉排序树的查找的效率与树的形状相挂钩。如果树的形状不够“规整”，那么查找的性能将大打折扣。</p>
<p>如:对于{62,88,58.47.35,73 51 99.37 93}和{35,37,47.51.58,62,73,88,93.99}这样的两个数组，可以构成如下二叉排序树。</p>
<p><img src="https://img-blog.csdnimg.cn/9585462bbc234cc1835731b63f677ec3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>如果我们需要查找93，对于左边的二叉排序树，只需要查找4次就能找到，但是对于右边的二叉排序树，我们查找的效率却已经近似于O(n)了。</p>
<p>所以，尽管二叉排序树已经比之之前的结构得到了优化，但是它仍存在一些不足，如果我们还要提升二叉排序树的效率，考虑到他是树，我们可以把它再升级一下，也就是把二叉排序树变成一颗完全二叉树的形状，这就是平衡二叉树。</p>
<h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><p><strong>平衡二叉树 ，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。</strong></p>
<p>平衡二叉树，顾名思义，是一种高度平衡的二叉排序树。<strong>这里对高度平衡的定义为：二叉树的左子树深度与右子树深度的绝对值之差小于等于1。</strong>我们将<strong>二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF</strong> ，那么平衡二叉树上所有结点的平衡因乎只可能是 -1,0,1. 只要二叉树上有 个结点BF的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>平衡二叉树与非平衡二叉树的例子</p>
<p><img src="https://img-blog.csdnimg.cn/7705b34fa68e41938fa765d0c6021cda.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>基本结构:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiBalanceTNode</span> {</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> bf;</span><br><span class="line">    BiBalanceTNode* lchild, * rchild;</span><br><span class="line">}*BiBalanceTree;</span><br></pre></td></tr></tbody></table></figure>
<p>那么平衡二叉树如何构建呢，这里借助一个例子来展示:</p>
<p>假设有一数组:</p>
<p><img src="https://img-blog.csdnimg.cn/6233316038c343b1a6321216d9400e01.png" referrerpolicy="no-referrer"></p>
<p>对于该数组，我们正常构建前两个数字3,2但是当我们构建到1的时候这时候如果按照二叉排序树的构建，1就会在2,3的下一层，这时候就破坏了平衡二叉树的平衡性。为了能够让平衡二叉树平衡，我们需要对树进行右旋:</p>
<p><img src="https://img-blog.csdnimg.cn/334ab476fda649f1b01b69a68259acce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>接下来我们继续增加结点，当我们增加5的时候，这时候又破坏了平衡二叉树的平衡性，考虑到3和4的bf都是负值，所以我们进行左旋操作:</p>
<p><img src="https://img-blog.csdnimg.cn/d2e5e9b66ef14e5bb8068a8ff529d0d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>接下来我们继续增加结点，先增加结点6，增加了结点6之后因为破坏了平衡性，所以需要左旋，同时注意结点3，他本是4的左孩子，但是被旋转之后成为了2的右孩子，接着增加结点7，也是左旋即可。</p>
<p><img src="https://img-blog.csdnimg.cn/6a8f778613a64e0fb488959caf609ba8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>继续增加新的结点，首先先增加结点10，此时没有变化，但是当我们增加结点9的时候，注意我们此时如果直接左旋，那么得到的二叉树不符合二叉排序树的性质，这是因为<strong>需要被左旋的结点7的bf的符号与另一个需要被左旋的结点10的bf的符号相反</strong>，这是因为当bf符号相反的时候，我们进行旋转操作，<strong>相当于对同一个结点将他的左孩子or右孩子变为他的兄弟，在我们的例子中，就是把9从10的左孩子变为了10的右孩子，暗中篡改了顺序。</strong>而前面能够顺利地进行左右旋转，是因为两个需要被旋转的结点的bf同号。</p>
<p>那么我们该怎么做?既然符号不统一，而只有符号统一才能左右旋转，我们就先右旋转9和10，把符号统一，这样就能左旋转7和9了。</p>
<p><img src="https://img-blog.csdnimg.cn/fae10d213b874111b859e781eb9e63ab.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>当插入结点8的时候类似:因为结点6和9的bf符号不等，所以我们先右旋转7和9，这样bf的符号就相等了，此时我们就可以旋转6和7，从而得到平衡二叉树。</p>
<p><img src="https://img-blog.csdnimg.cn/c7d08a0597424459999de2f435509cea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>于是我们可以总结出这样的一套构建平衡二叉树的旋转的算法:</p>
<p>如果需要旋转，我们就根据bf的符号判断，<strong>如果bf符号一致，+号向右，-号向左，如果bf符号不一致，我们就先让他一致，然后+号向右，-号向左。</strong></p>
<p>右旋操作定义如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(BiBalanceTree* T)</span> </span>{</span><br><span class="line">    BiBalanceTree p;</span><br><span class="line">    p = (*T)-&gt;lchild;</span><br><span class="line">    (*T)-&gt;lchild = p-&gt;rchild;</span><br><span class="line">    p-&gt;rchild = (*T);</span><br><span class="line">    *T = p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码的意思是，首先我们传入一个二叉排序树，当我们插入一个破坏了平衡性的结点，我们就需要进行右旋，首先存储二叉排序树的左子树的根结点，然后将传入的二叉排序树的根节点的左孩子更新为该二叉排序树的左子树的根节点的右孩子，然后再把保存的p的右孩子指针指向传入的二叉排序树的根节点，最后将该根节点修改为p即可。</p>
<p>右旋代码的含义如下图:</p>
<p><img src="https://img-blog.csdnimg.cn/a5e827b59e35423fabdd10bfbc570d79.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>右旋的实例:</p>
<p><img src="https://img-blog.csdnimg.cn/26557ff883d74932a1b8c5187d73e8ed.png" referrerpolicy="no-referrer"></p>
<p><img src="https://img-blog.csdnimg.cn/a535505d4e20477b85f81b2aae1821b6.png" referrerpolicy="no-referrer"></p>
<p>类似的，我们可以得到左旋代码如下:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Rotate</span><span class="params">(BiBalanceTree* T)</span> </span>{</span><br><span class="line">    BiBalanceTree p;</span><br><span class="line">    p = (*T)-&gt;rchild;</span><br><span class="line">    (*T)-&gt;rchild = p-&gt;lchild;</span><br><span class="line">    p-&gt;lchild = (*T);</span><br><span class="line">    *T = p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>左平衡旋转</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LeftBalance</span><span class="params">(BiBalanceTree* T)</span> </span>{</span><br><span class="line">    BiBalanceTree L,Lr;</span><br><span class="line">    L = (*T)-&gt;lchild;</span><br><span class="line">    <span class="keyword">switch</span> (L-&gt;bf) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//新加入的结点在T的左子树的左孩子上，说明bf同号</span></span><br><span class="line">        (*T)-&gt;bf = L-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">R_Rotate</span>(T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:<span class="comment">//新加入的结点在T的左子树的右孩子上，说明bf不同号，需要双旋</span></span><br><span class="line">        Lr = L-&gt;rchild;</span><br><span class="line">        <span class="keyword">switch</span> (Lr-&gt;bf) {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            (*T)-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">            L-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            (*T)-&gt;bf = L-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            (*T)-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            L-&gt;bf = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        Lr-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">L_Rotate</span>(&amp;(*T)-&gt;lchild);</span><br><span class="line">        <span class="built_in">R_Rotate</span>(T);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/cc2f8e4cf3494c22a043a004852163e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"><img src="https://img-blog.csdnimg.cn/87c9b52586364d219b6c2dcf421e137e.png" referrerpolicy="no-referrer"></p>
<p>类似的有右平衡旋转:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RightBalance</span><span class="params">(BiBalanceTree* T)</span> </span>{</span><br><span class="line">    BiBalanceTree R, Rl;</span><br><span class="line">    R = (*T)-&gt;rchild;</span><br><span class="line">    <span class="keyword">switch</span> (R-&gt;bf) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:<span class="comment">//新加入的结点在T的右子树的右孩子上，说明bf同号</span></span><br><span class="line">        (*T)-&gt;bf = R-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">L_Rotate</span>(T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//新加入的结点在T的右子树的左孩子上，说明bf不同号，需要双旋</span></span><br><span class="line">        Rl = R-&gt;lchild;</span><br><span class="line">        <span class="keyword">switch</span> (Rl-&gt;bf) {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            (*T)-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            R-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            (*T)-&gt;bf = R-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            (*T)-&gt;bf = <span class="number">1</span>;</span><br><span class="line">            R-&gt;bf = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        Rl-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">R_Rotate</span>(&amp;(*T)-&gt;rchild);</span><br><span class="line">        <span class="built_in">L_Rotate</span>(T);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后我们可以得到AVL树的插入代码:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertAVL</span><span class="params">(BiBalanceTree* T, <span class="type">int</span> key, <span class="type">bool</span>&amp; taller)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!*T) {</span><br><span class="line">        *T = <span class="keyword">new</span> BiBalanceTNode;</span><br><span class="line">        (*T)-&gt;data = key;</span><br><span class="line">        (*T)-&gt;lchild = (*T)-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        (*T)-&gt;bf = <span class="number">0</span>;</span><br><span class="line">        taller = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> ((*T)-&gt;data == key) {</span><br><span class="line">            taller = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key &lt; (*T)-&gt;data) {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">InsertAVL</span>(&amp;(*T)-&gt;lchild, key, taller)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (taller) {</span><br><span class="line">                <span class="keyword">switch</span> ((*T)-&gt;bf) {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">LeftBalance</span>(T);</span><br><span class="line">                    taller = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    (*T)-&gt;bf = <span class="number">1</span>;</span><br><span class="line">                    taller = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                    (*T)-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                    taller = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">InsertAVL</span>(&amp;(*T)-&gt;rchild, key, taller)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (taller) {</span><br><span class="line">                <span class="keyword">switch</span> ((*T)-&gt;bf) {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    (*T)-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                    taller = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    (*T)-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">                    taller = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                    <span class="built_in">RightBalance</span>(T);</span><br><span class="line">                    taller = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>总结下来AVL树的插入分4种类型:</strong></p>
<p><strong>左左类型:因为插入一个左子树的左孩子结点导致不平衡，需要单向右旋</strong></p>
<p><strong>左右类型:因为插入一个左子树的右孩子导致不平衡，需要先左旋再右旋（其实就是把左右变成左左）</strong></p>
<p><strong>右右类型:因为插入一个右子树的右孩子导致不平衡，需要单向左旋</strong></p>
<p><strong>右左类型:因为插入一个右子树的左孩子导致不平衡，需要先右旋再左旋（其实就是把右左变为右右）</strong></p>
<p>整个平衡二叉树的代码非常长，也有非常多的细节</p>
<p>这里记录一组数据( 3,2,1,4,5,6,7,10,9,8 )方便自己以后debug跟踪查看构建AVL树的过程。</p>
<p>AVL树的删除代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteAVL</span><span class="params">(BiBalanceTree* T,BiBalanceTree parent,<span class="type">int</span> key,<span class="type">bool</span>&amp; shorter)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!*T) {</span><br><span class="line">        shorter = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> ((*T)-&gt;data == key) {</span><br><span class="line">            <span class="keyword">if</span> (!(*T)-&gt;lchild) {</span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;data &gt;= key) {</span><br><span class="line">                    parent-&gt;lchild = (*T)-&gt;rchild;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    parent-&gt;rchild = (*T)-&gt;rchild;</span><br><span class="line">                }</span><br><span class="line">                shorter = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(*T)-&gt;rchild) {</span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;data &gt;= key) {</span><br><span class="line">                    parent-&gt;lchild = (*T)-&gt;lchild;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    parent-&gt;rchild = (*T)-&gt;lchild;</span><br><span class="line">                }</span><br><span class="line">                shorter = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                BiBalanceTree temp = (*T)-&gt;lchild;</span><br><span class="line">                <span class="keyword">while</span> (temp-&gt;rchild) {</span><br><span class="line">                    temp = temp-&gt;rchild;</span><br><span class="line">                }</span><br><span class="line">                (*T)-&gt;data = temp-&gt;data;</span><br><span class="line">                <span class="built_in">DeleteAVL</span>(&amp;(*T)-&gt;lchild, *T,temp-&gt;data,shorter);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((*T)-&gt;data &gt; key) {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">DeleteAVL</span>(&amp;(*T)-&gt;lchild,*T,key,shorter)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shorter) {</span><br><span class="line">                <span class="keyword">switch</span> ((*T)-&gt;bf) {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    (*T)-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                    shorter = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    (*T)-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">                    shorter = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">if</span> ((*T)-&gt;rchild-&gt;bf == <span class="number">0</span>) {</span><br><span class="line">                        shorter = <span class="literal">false</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        shorter = <span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="built_in">RightBalance</span>(T);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">DeleteAVL</span>(&amp;(*T)-&gt;rchild,*T,key,shorter)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shorter) {</span><br><span class="line">                <span class="keyword">switch</span> ((*T)-&gt;bf) {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                    (*T)-&gt;bf = <span class="number">0</span>;</span><br><span class="line">                    shorter = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    (*T)-&gt;bf = <span class="number">1</span>;</span><br><span class="line">                    shorter = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> ((*T)-&gt;lchild-&gt;bf == <span class="number">0</span>) {</span><br><span class="line">                        shorter = <span class="literal">false</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        shorter = <span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="built_in">LeftBalance</span>(T);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AVL树的构建与删除调用</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiBalanceTree* T = <span class="keyword">new</span> BiBalanceTree{<span class="literal">NULL</span>};<span class="comment">//AVL树的构建调用</span></span><br><span class="line"><span class="type">bool</span> status = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">InsertAVL</span>(T, key,status);</span><br><span class="line"><span class="built_in">DeleteAVL</span>(T, *T, key, status);</span><br></pre></td></tr></tbody></table></figure>
<p>总之，如果我们需要查找的集合本身就有顺序，并且存在需要我们频繁的插入与删除，那么使用平衡二叉树实现动态查找表的结构是相当理想的(时间复杂度，空间复杂度均为O(logn)</p>
<p>更新版:AVL树插入与删除:</p>
<p>删除可以归纳为：</p>
<p><strong>对于叶子结点，如果删除导致了父结点不平衡，只需要左转或右转</strong></p>
<p><strong>对于非叶子结点，如果只有左或右孩子，不需要旋转，但是如果左右孩子都有，删除后如果bf为-2，左旋，如果bf不为-2，此时就算该结点已经平衡仍需要判断其左孩子是否平衡，此时如果左孩子不平衡bf为2，右旋（要判断左孩子是因为我们采取了直接前驱代替）</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(AVLTree T,AVLTree&amp; parent)</span> </span>{</span><br><span class="line">    parent-&gt;lchild = T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild = parent;</span><br><span class="line">    parent = T;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Lotate</span><span class="params">(AVLTree T,AVLTree&amp; parent)</span> </span>{</span><br><span class="line">    parent-&gt;rchild = T-&gt;lchild;</span><br><span class="line">    T-&gt;lchild = parent;</span><br><span class="line">    parent = T;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(AVLTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getHeight</span>(T-&gt;lchild), <span class="built_in">getHeight</span>(T-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getBf</span><span class="params">(AVLTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    T-&gt;bf = <span class="built_in">getHeight</span>(T-&gt;lchild) - <span class="built_in">getHeight</span>(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">getBf</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">getBf</span>(T-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertAVL</span><span class="params">(AVLTree&amp; T, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">        T = <span class="keyword">new</span> AVLNode{ key,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> };</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; T-&gt;data) {</span><br><span class="line">            <span class="built_in">InsertAVL</span>(T-&gt;lchild, key);</span><br><span class="line">            <span class="built_in">getBf</span>(T);</span><br><span class="line">            <span class="keyword">if</span> (T-&gt;bf == <span class="number">2</span>) {</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;lchild-&gt;bf == <span class="number">1</span>) {</span><br><span class="line">                    <span class="built_in">R_Rotate</span>(T-&gt;lchild, T);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild-&gt;bf == <span class="number">-1</span>) {</span><br><span class="line">                    <span class="built_in">L_Lotate</span>(T-&gt;lchild-&gt;rchild, T-&gt;lchild);</span><br><span class="line">                    <span class="built_in">R_Rotate</span>(T-&gt;lchild, T);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">InsertAVL</span>(T-&gt;rchild, key);</span><br><span class="line">            <span class="built_in">getBf</span>(T);</span><br><span class="line">            <span class="keyword">if</span> (T-&gt;bf == <span class="number">-2</span>) {</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;rchild-&gt;bf == <span class="number">1</span>) {</span><br><span class="line">                    <span class="built_in">R_Rotate</span>(T-&gt;rchild-&gt;lchild, T-&gt;rchild);</span><br><span class="line">                    <span class="built_in">L_Lotate</span>(T-&gt;rchild, T);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;rchild-&gt;bf == <span class="number">-1</span>) {</span><br><span class="line">                    <span class="built_in">L_Lotate</span>(T-&gt;rchild, T);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(AVLTree&amp; parent)</span> </span>{</span><br><span class="line">    AVLTree temp = parent;</span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;lchild == <span class="literal">NULL</span>) {</span><br><span class="line">        parent = temp-&gt;rchild;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;rchild == <span class="literal">NULL</span>) {</span><br><span class="line">        parent = temp-&gt;lchild;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    AVLTree p = temp-&gt;lchild;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rchild == <span class="literal">NULL</span>) {</span><br><span class="line">        p-&gt;rchild = parent-&gt;rchild;</span><br><span class="line">        parent = p;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    AVLTree t = p;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;rchild) {</span><br><span class="line">        t = p;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    }</span><br><span class="line">    t-&gt;rchild = p-&gt;lchild;</span><br><span class="line">    parent-&gt;data = p-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteAVL</span><span class="params">(AVLTree&amp; T,AVLTree&amp; parent,<span class="type">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == key) {</span><br><span class="line">        <span class="type">int</span> kind = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!T-&gt;lchild &amp;&amp; !T-&gt;rchild) {</span><br><span class="line">            kind = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild &amp;&amp; T-&gt;rchild){</span><br><span class="line">            kind = <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">Delete</span>(T);</span><br><span class="line">        <span class="keyword">switch</span> (kind) {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">getBf</span>(parent);</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;bf == <span class="number">2</span>) {</span><br><span class="line">                <span class="built_in">R_Rotate</span>(parent-&gt;lchild, parent);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;bf == <span class="number">-2</span>) {</span><br><span class="line">                <span class="built_in">L_Lotate</span>(parent-&gt;rchild, parent);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">getBf</span>(T);</span><br><span class="line">            <span class="keyword">if</span> (T-&gt;bf == <span class="number">-2</span>) {</span><br><span class="line">                <span class="built_in">L_Lotate</span>(T-&gt;rchild, T);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild-&gt;bf == <span class="number">2</span>) {</span><br><span class="line">                <span class="built_in">R_Rotate</span>(T-&gt;lchild-&gt;lchild, T-&gt;lchild);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data) {</span><br><span class="line">        <span class="built_in">DeleteAVL</span>(T-&gt;lchild, T, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">DeleteAVL</span>(T-&gt;rchild, T, key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>删除的逻辑（参考了一下别人的图）:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21388535/article/details/105601270">AVL树的删除</a></p>
<h3 id="多路查找树（B树）"><a href="#多路查找树（B树）" class="headerlink" title="多路查找树（B树）"></a>多路查找树（B树）</h3><p><strong>多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。</strong></p>
<p>引入多路查找树，是因为尽管我们有了二叉排序树，平衡二叉树这样的具有优良性质的数据结构，但是我们的数据集合如果过于庞大时，由于二叉树本身的良好性质是建立在二叉树只能有两个孩子这一限制上的，所以这时候如果我们还是按照原来的方法构建树，那么会导致树过于庞大（树高非常大或树的度特别大等），除此之外，在大型数据库中，由于数据和索引都存储在外存，所以当涉及到内外存之间的数据交换的时候，对内存的访问快慢就成了制约快慢的关键因素，由于平衡二叉树一个结点只存储一个数据的缘故，会导致对内存更频繁地访问，极大地降低了查找的速度。为了优化这一结构，引入了多路查找树。</p>
<p>对于多路查找树，每一个结点可以存储多少个元素，以及树的孩子数的多少是非常关键的，其中有4种特殊形式 <strong>2-3树 2-3-4 树、B树和 B+树</strong></p>
<h4 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h4><p>2-3 树是这样的一棵多路查找树;<strong>其中的每个结点都具有两个孩子或三个孩子。</strong></p>
<p><strong>一个2结点包含一个元素和两孩子(或没有孩子)</strong> 且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同 的是，这个结点要么没有孩子，要有就有两个，不能只有一个孩子</p>
<p><strong>一个3结点包含一大一小两个元素和三个孩子(或没有孩子) 结点要么没有孩子，要么具有3个孩子。</strong>如果某个结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素</p>
<p><strong>并且 2-3 树中所有的叶子都在同一层次上。</strong></p>
<h5 id="2-3树的插入"><a href="#2-3树的插入" class="headerlink" title="2-3树的插入"></a>2-3树的插入</h5><p>2-3树的插入分为三种情况:</p>
<p>1.如果当前的树为空树，直接插入一个2结点</p>
<p>2.插入到一个2结点的叶子上。由于本身该结点是2结点，所以将其纠正为3结点即可。</p>
<p>3.插入到一个三结点上。由于3结点本身已经是2-3树的最大结点，所以需要修正。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//*********************************************结构************************************//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span> {</span><br><span class="line">	<span class="type">int</span> keyNum;</span><br><span class="line">	<span class="type">int</span>* key;</span><br><span class="line">	BTNode* parent;</span><br><span class="line">	BTNode** ptr;</span><br><span class="line">}*BTree;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Result</span> {</span><br><span class="line">	BTNode* pt;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="type">int</span> tag;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//m阶B-树</span></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="comment">//*********************************************插入与查找********************************//</span></span><br><span class="line"><span class="comment">//功能：在结点T中查找关键字num的插入位置i</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search</span><span class="params">(BTree T, <span class="type">int</span> num)</span> </span>{</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; T-&gt;keyNum &amp;&amp; T-&gt;key[i + <span class="number">1</span>] &lt;= num; i++);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在树T中查找关键字key，返回查找结果类型</span></span><br><span class="line"><span class="function">Result* <span class="title">SearchBT</span><span class="params">(BTree T,BTree t, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">	<span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">	BTree p = t, q = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; !found) {</span><br><span class="line">		i = <span class="built_in">Search</span>(p, key);</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; p-&gt;key[i] == key) {</span><br><span class="line">			found = <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			q = p;</span><br><span class="line">			p = p-&gt;ptr[i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (found) {</span><br><span class="line">		Result* r = <span class="keyword">new</span> Result{ p,i,<span class="number">1</span> };</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		Result* r = <span class="keyword">new</span> Result{ q,i,<span class="number">0</span> };</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//查找结果输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchBT</span><span class="params">(BTree T, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">	Result* r = <span class="built_in">SearchBT</span>(T,T,key);</span><br><span class="line">	<span class="keyword">if</span> (!r-&gt;tag) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"-1"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		BTree p = r-&gt;pt;</span><br><span class="line">		cout &lt;&lt; p-&gt;key[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= p-&gt;keyNum; i++) {</span><br><span class="line">			cout &lt;&lt; <span class="string">":"</span> &lt;&lt; p-&gt;key[i];</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; <span class="string">' '</span> &lt;&lt; r-&gt;index &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//生成新的根结点T,原p和q为子树指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NewRoot</span><span class="params">(BTree&amp; T, <span class="type">int</span> num, BTree p, BTree q)</span> </span>{</span><br><span class="line">	p = T;</span><br><span class="line">	T = <span class="keyword">new</span> BTNode;</span><br><span class="line">	T-&gt;keyNum = <span class="number">1</span>;</span><br><span class="line">	T-&gt;key = <span class="keyword">new</span> <span class="type">int</span>[m + <span class="number">1</span>];</span><br><span class="line">	T-&gt;ptr = <span class="keyword">new</span> BTree[m + <span class="number">1</span>];</span><br><span class="line">	T-&gt;ptr[<span class="number">0</span>] = p;</span><br><span class="line">	T-&gt;ptr[<span class="number">1</span>] = q;</span><br><span class="line">	T-&gt;key[<span class="number">1</span>] = num;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">		p-&gt;parent = T;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (q != <span class="literal">NULL</span>) {</span><br><span class="line">		q-&gt;parent = T;</span><br><span class="line">	}</span><br><span class="line">	T-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//关键字key和结点T分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(BTree&amp; T, <span class="type">int</span> key, BTree t, <span class="type">int</span> index)</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = T-&gt;keyNum; j &gt; index; j--) {</span><br><span class="line">		T-&gt;key[j + <span class="number">1</span>] = T-&gt;key[j];</span><br><span class="line">		T-&gt;ptr[j + <span class="number">1</span>] = T-&gt;ptr[j];</span><br><span class="line">	}</span><br><span class="line">	T-&gt;key[index + <span class="number">1</span>] = key;</span><br><span class="line">	T-&gt;ptr[index + <span class="number">1</span>] = t;</span><br><span class="line">	<span class="keyword">if</span> (t != <span class="literal">NULL</span>) {</span><br><span class="line">		t-&gt;parent = T;</span><br><span class="line">	}</span><br><span class="line">	T-&gt;keyNum++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将结点q分裂成两个结点,前一半保留,后一半移入结点ap</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(BTree&amp; q, <span class="type">int</span> s, BTree&amp; ap)</span> </span>{</span><br><span class="line">	ap = <span class="keyword">new</span> BTNode;</span><br><span class="line">	ap-&gt;key = <span class="keyword">new</span> <span class="type">int</span>[m + <span class="number">1</span>];</span><br><span class="line">	ap-&gt;ptr = <span class="keyword">new</span> BTree[m + <span class="number">1</span>];</span><br><span class="line">	ap-&gt;ptr[<span class="number">0</span>] = q-&gt;ptr[s];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = s + <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">		ap-&gt;key[i - s] = q-&gt;key[i];</span><br><span class="line">		ap-&gt;ptr[i - s] = q-&gt;ptr[i];</span><br><span class="line">	}</span><br><span class="line">	ap-&gt;keyNum = q-&gt;keyNum - s;</span><br><span class="line">	ap-&gt;parent = q-&gt;parent;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= q-&gt;keyNum - s; i++) {</span><br><span class="line">		<span class="keyword">if</span> (ap-&gt;ptr[i] != <span class="literal">NULL</span>) {</span><br><span class="line">			ap-&gt;ptr[i]-&gt;parent = ap;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	q-&gt;keyNum = s - <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在树T中插入关键字key，返回插入结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertBT</span><span class="params">(BTree&amp; T, <span class="type">int</span> key, BTree t, <span class="type">int</span> index)</span> </span>{</span><br><span class="line">	<span class="type">int</span> x = key;</span><br><span class="line">	BTree ap = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> finished = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (t &amp;&amp; !finished) {</span><br><span class="line">		<span class="built_in">Insert</span>(t, x, ap, index);</span><br><span class="line">		<span class="keyword">if</span> (t-&gt;keyNum &lt; m) {</span><br><span class="line">			finished = <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			<span class="type">int</span> s = m / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//分裂点右边的结点</span></span><br><span class="line">			<span class="built_in">split</span>(t, s, ap);</span><br><span class="line">			x = t-&gt;key[s];</span><br><span class="line">			t = t-&gt;parent;</span><br><span class="line">			<span class="keyword">if</span> (t) {</span><br><span class="line">				index = <span class="built_in">Search</span>(t, x);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (!finished) {</span><br><span class="line">		<span class="built_in">NewRoot</span>(T, x, t, ap);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//调用插入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertBT</span><span class="params">(BTree&amp; T,<span class="type">int</span> key)</span> </span>{</span><br><span class="line">	Result* r = <span class="built_in">SearchBT</span>(T,T,key);</span><br><span class="line">	<span class="keyword">if</span> (!r-&gt;tag) {</span><br><span class="line">		<span class="built_in">InsertBT</span>(T, key, r-&gt;pt, r-&gt;index);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(BTree T)</span> </span>{</span><br><span class="line">	queue&lt;BTree&gt; q;</span><br><span class="line">	BTree p = T;</span><br><span class="line">	<span class="keyword">if</span> (p) {</span><br><span class="line">		q.<span class="built_in">push</span>(p);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">		p = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; p-&gt;key[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= p-&gt;keyNum; i++) {</span><br><span class="line">			cout &lt;&lt; <span class="string">":"</span> &lt;&lt; p-&gt;key[i];</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= p-&gt;keyNum; i++) {</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;ptr[i] == <span class="literal">NULL</span>) {</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			q.<span class="built_in">push</span>(p-&gt;ptr[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//*********************************************删除************************************//</span></span><br><span class="line"><span class="comment">//从p结点删除key[i]和它的孩子指针ptr[i]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(BTNode* p, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= p-&gt;keyNum; j++) {                    <span class="comment">//前移删除key[i]和ptr[i]</span></span><br><span class="line">		p-&gt;key[j - <span class="number">1</span>] = p-&gt;key[j];</span><br><span class="line">		p-&gt;ptr[j - <span class="number">1</span>] = p-&gt;ptr[j];</span><br><span class="line">	}</span><br><span class="line">	p-&gt;keyNum--;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//寻找替代值（右子树中最小的关键字）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Substitution</span><span class="params">(BTNode* p, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">	BTNode* q;</span><br><span class="line">	<span class="keyword">for</span> (q = p-&gt;ptr[i]; q-&gt;ptr[<span class="number">0</span>] != <span class="literal">NULL</span>; q = q-&gt;ptr[<span class="number">0</span>]);</span><br><span class="line">	p-&gt;key[i] = q-&gt;key[<span class="number">1</span>];                            <span class="comment">//复制关键字值</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//反映是否在结点p中是否查找到关键字k </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindBTNode</span><span class="params">(BTNode* p, <span class="type">int</span> k, <span class="type">int</span>&amp; i)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (k &lt; p-&gt;key[<span class="number">1</span>]) {                                <span class="comment">//结点p中查找关键字k失败 </span></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {                                           <span class="comment">//在p结点中查找</span></span><br><span class="line">		i = p-&gt;keyNum;</span><br><span class="line">		<span class="keyword">while</span> (k &lt; p-&gt;key[i] &amp;&amp; i&gt;<span class="number">1</span>)</span><br><span class="line">			i--;</span><br><span class="line">		<span class="keyword">if</span> (k == p-&gt;key[i])                            <span class="comment">//结点p中查找关键字k成功 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//双亲结点p中的最后一个关键字移入右结点q中</span></span><br><span class="line"><span class="comment">//将左结点aq中的最后一个关键字移入双亲结点p中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(BTNode* p, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	BTNode* q = p-&gt;ptr[i];</span><br><span class="line">	BTNode* aq = p-&gt;ptr[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (j = q-&gt;keyNum; j &gt; <span class="number">0</span>; j--) {                       <span class="comment">//将右兄弟q中所有关键字向后移动一位</span></span><br><span class="line">		q-&gt;key[j + <span class="number">1</span>] = q-&gt;key[j];</span><br><span class="line">		q-&gt;ptr[j + <span class="number">1</span>] = q-&gt;ptr[j];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	q-&gt;ptr[<span class="number">1</span>] = q-&gt;ptr[<span class="number">0</span>];                            <span class="comment">//从双亲结点p移动关键字到右兄弟q中</span></span><br><span class="line">	q-&gt;key[<span class="number">1</span>] = p-&gt;key[i];</span><br><span class="line">	q-&gt;keyNum++;</span><br><span class="line"></span><br><span class="line">	p-&gt;key[i] = aq-&gt;key[aq-&gt;keyNum];                  <span class="comment">//将左兄弟aq中最后一个关键字移动到双亲结点p中</span></span><br><span class="line">	p-&gt;ptr[i]-&gt;ptr[<span class="number">0</span>] = aq-&gt;ptr[aq-&gt;keyNum];</span><br><span class="line">	aq-&gt;keyNum--;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//双亲结点p中的第一个关键字移入左结点aq中，</span></span><br><span class="line"><span class="comment">//将右结点q中的第一个关键字移入双亲结点p中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveLeft</span><span class="params">(BTNode* p, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	BTNode* aq = p-&gt;ptr[i - <span class="number">1</span>];</span><br><span class="line">	BTNode* q = p-&gt;ptr[i];</span><br><span class="line"></span><br><span class="line">	aq-&gt;keyNum++;                                   <span class="comment">//把双亲结点p中的关键字移动到左兄弟aq中</span></span><br><span class="line">	aq-&gt;key[aq-&gt;keyNum] = p-&gt;key[i];</span><br><span class="line">	aq-&gt;ptr[aq-&gt;keyNum] = p-&gt;ptr[i]-&gt;ptr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	p-&gt;key[i] = q-&gt;key[<span class="number">1</span>];                            <span class="comment">//把右兄弟q中的关键字移动到双亲节点p中</span></span><br><span class="line">	q-&gt;ptr[<span class="number">0</span>] = q-&gt;ptr[<span class="number">1</span>];</span><br><span class="line">	q-&gt;keyNum--;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= q-&gt;keyNum; j++) {                     <span class="comment">//将右兄弟q中所有关键字向前移动一位</span></span><br><span class="line">		q-&gt;key[j] = q-&gt;key[j + <span class="number">1</span>];</span><br><span class="line">		q-&gt;ptr[j] = q-&gt;ptr[j + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//双亲结点p、右结点q合并入左结点aq，</span></span><br><span class="line"><span class="comment">//并调整双亲结点p中的剩余关键字的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Combine</span><span class="params">(BTNode* p, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	BTNode* q = p-&gt;ptr[i];</span><br><span class="line">	BTNode* aq = p-&gt;ptr[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	aq-&gt;keyNum++;                                  <span class="comment">//将双亲结点的关键字p-&gt;key[i]插入到左结点aq     </span></span><br><span class="line">	aq-&gt;key[aq-&gt;keyNum] = p-&gt;key[i];</span><br><span class="line">	aq-&gt;ptr[aq-&gt;keyNum] = q-&gt;ptr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= q-&gt;keyNum; j++) {                      <span class="comment">//将右结点q中的所有关键字插入到左结点aq </span></span><br><span class="line">		aq-&gt;keyNum++;</span><br><span class="line">		aq-&gt;key[aq-&gt;keyNum] = q-&gt;key[j];</span><br><span class="line">		aq-&gt;ptr[aq-&gt;keyNum] = q-&gt;ptr[j];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (j = i; j &lt; p-&gt;keyNum; j++) {                       <span class="comment">//将双亲结点p中的p-&gt;key[i]后的所有关键字向前移动一位 </span></span><br><span class="line">		p-&gt;key[j] = p-&gt;key[j + <span class="number">1</span>];</span><br><span class="line">		p-&gt;ptr[j] = p-&gt;ptr[j + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	p-&gt;keyNum--;                                    <span class="comment">//修改双亲结点p的keyNum值 </span></span><br><span class="line">	<span class="built_in">free</span>(q);                                        <span class="comment">//释放空右结点q的空间</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//删除结点p中的第i个关键字后,调整B树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustBTree</span><span class="params">(BTNode* p, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0</span>)                                        <span class="comment">//删除的是最左边关键字</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;ptr[<span class="number">1</span>]-&gt;keyNum &gt; (m - <span class="number">1</span>) / <span class="number">2</span>)                   <span class="comment">//右结点可以借</span></span><br><span class="line">			<span class="built_in">MoveLeft</span>(p, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span>                                        <span class="comment">//右兄弟不够借 </span></span><br><span class="line">			<span class="built_in">Combine</span>(p, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i == p-&gt;keyNum)                           <span class="comment">//删除的是最右边关键字</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;ptr[i - <span class="number">1</span>]-&gt;keyNum &gt; (m - <span class="number">1</span>) / <span class="number">2</span>)                 <span class="comment">//左结点可以借 </span></span><br><span class="line">			<span class="built_in">MoveRight</span>(p, i);</span><br><span class="line">		<span class="keyword">else</span>                                        <span class="comment">//左结点不够借 </span></span><br><span class="line">			<span class="built_in">Combine</span>(p, i);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;ptr[i - <span class="number">1</span>]-&gt;keyNum &gt; (m - <span class="number">1</span>) / <span class="number">2</span>)                <span class="comment">//删除关键字在中部且左结点够借 </span></span><br><span class="line">		<span class="built_in">MoveRight</span>(p, i);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;ptr[i + <span class="number">1</span>]-&gt;keyNum &gt; (m - <span class="number">1</span>) / <span class="number">2</span>)                <span class="comment">//删除关键字在中部且右结点够借 </span></span><br><span class="line">		<span class="built_in">MoveLeft</span>(p, i + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span>                                            <span class="comment">//删除关键字在中部且左右结点都不够借</span></span><br><span class="line">		<span class="built_in">Combine</span>(p, i);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在结点p中查找并删除关键字k</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BTNodeDelete</span><span class="params">(BTNode* p, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> found_tag;                                  <span class="comment">//查找标志 </span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		found_tag = <span class="built_in">FindBTNode</span>(p, k, i);                <span class="comment">//返回查找结果 </span></span><br><span class="line">		<span class="keyword">if</span> (found_tag == <span class="number">1</span>) {                           <span class="comment">//查找成功 </span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;ptr[i - <span class="number">1</span>] != <span class="literal">NULL</span>) {                  <span class="comment">//删除的是非叶子结点</span></span><br><span class="line">				<span class="built_in">Substitution</span>(p, i);                  <span class="comment">//寻找相邻关键字(右子树中最小的关键字) </span></span><br><span class="line">				<span class="built_in">BTNodeDelete</span>(p-&gt;ptr[i], p-&gt;key[i]);  <span class="comment">//执行删除操作 </span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">Remove</span>(p, i);                        <span class="comment">//从结点p中位置i处删除关键字</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			found_tag = <span class="built_in">BTNodeDelete</span>(p-&gt;ptr[i], k);    <span class="comment">//沿孩子结点递归查找并删除关键字k</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;ptr[i] != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;ptr[i]-&gt;keyNum &lt; (m - <span class="number">1</span>) / <span class="number">2</span>)               <span class="comment">//删除后关键字个数小于MIN</span></span><br><span class="line">				<span class="built_in">AdjustBTree</span>(p, i);                   <span class="comment">//调整B树 </span></span><br><span class="line">		<span class="keyword">return</span> found_tag;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//构建删除框架，执行删除操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BTreeDelete</span><span class="params">(BTree&amp; t, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">	BTNode* p;</span><br><span class="line">	<span class="type">int</span> a = <span class="built_in">BTNodeDelete</span>(t, k);                        <span class="comment">//删除关键字k </span></span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>)                                        <span class="comment">//查找失败 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"   关键字%d不在B树中\n"</span>, k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;keyNum == <span class="number">0</span>) {                          <span class="comment">//调整 </span></span><br><span class="line">		p = t;</span><br><span class="line">		t = t-&gt;ptr[<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//*********************************************测试************************************//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) {</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		<span class="type">int</span> n, k, key;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		BTree T = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (n--) {</span><br><span class="line">			cin &gt;&gt; key;</span><br><span class="line">			<span class="built_in">InsertBT</span>(T,key);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">level</span>(T);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; k;</span><br><span class="line">		<span class="keyword">while</span> (k--) {</span><br><span class="line">			cin &gt;&gt; key;</span><br><span class="line">			<span class="built_in">SearchBT</span>(T,key);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h3><p>前面我们的查找（尤其是顺序查找），都是在做一件事情:遍历，然后判断信息是=还是≠，这样的查找方式很方便我们理解，但是每次查找都需要依赖于在一个极大的范围的数据集合下遍历，即使是我们优化了数据的存储结构（多路查找树、AVL树等等），仍不能避免这个问题。</p>
<p>我们是否有办法，知道我们要查找的数据，或者说它的关键字(key)通过某种变换，就能直接获取到它的存储位置呢？这就是散列表（哈希表)的思想。</p>
<p>定义:存在某个函数f，使得如下式子成立:</p>
<p><img src="https://img-blog.csdnimg.cn/f6be1a386c47435eb1befa01cb937c5e.png" referrerpolicy="no-referrer"></p>
<p>这样我们就得到了一个新的方法，只需要查找关键字，就能够获得对应数据的存储位置。这种存储技术称为<strong>散列技术。</strong></p>
<p><strong>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f ，使得每个关键字 key 对应一个存储位置f (key)</strong> 。查找时，根据这个确定的对应关系找到给定值 key 的映射f(key) ，若查找集合中存在这个记录，则必定在f(key)的位置上。</p>
<p><strong>这里我们把这种对应关系称为散列函数，又称为哈希 （Hash ）函数</strong>。按这个思想， <strong>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash Table）</strong>那么关键字对应的记录存储位置我们称为散列地址。</p>
<h4 id="散列表的查找过程"><a href="#散列表的查找过程" class="headerlink" title="散列表的查找过程"></a>散列表的查找过程</h4><p>1.在我们存储散列数据的时候，我们首先通过散列函数计算出存储的地址，并按照这个散列地址存储该记录。</p>
<p>2.而当我们查找记录时，我们通过同样的散列函数计算出记录的散列地址，按照计算出的散列地址查找记录。</p>
<p>虽然散列技术提供了通过关键字的查找方法，但是散列技术也因此不具备了很多通用数据结构具备的能力。</p>
<p>比如散列技术查找一个范围内的值，比如查找全国处于青年期的所有人的姓名，青年期是一个年龄范围，这时候散列技术就无能为力了。</p>
<p>可以看到，由于散列技术的特殊性的关键在于散列函数，因此重点便放在<strong>散列函数</strong>的构造上。</p>
<h3 id="散列函数（哈希函数）"><a href="#散列函数（哈希函数）" class="headerlink" title="散列函数（哈希函数）"></a>散列函数（哈希函数）</h3><p>提到散列函数，不能避免的一个问题就是<strong>散列冲突（散列碰撞，哈希碰撞，哈希冲突）</strong>。</p>
<p>一般来说，我们构造散列函数的时候，总是期望能够达到f(x) = y，同时一个y只对应一个x的效果。但是，显示往往不是如意的，我们很可能会遇到<strong>给定的两个关键字key1 ≠ key2，但是f(key1) = f(key2)的情况，发生这种情况，就叫做散列冲突。此时key1与key2互相称为同义词。</strong></p>
<p>这种情况一旦发生非常糟糕，因为他有可能导致隐藏的非法查找或查找错误。因此我们在构造散列函数的时候，也要尽可能避免这个问题，同时如果实在无法避免，也要知道如何处理。</p>
<p>散列函数的构造原则:</p>
<p><strong>1.计算简单</strong></p>
<p>这里的计算简单指的是除了函数的计算过程相对简单外，还包括了对散列冲突的处理。即使你能够设计出一套算法处理了所有的散列冲突，但是计算量极其庞大，那也是无意义的。</p>
<p><strong>2.散列地址的分布足够均匀</strong></p>
<p>还是散列冲突带来的讨论，这样均匀分布存储可以有效提升存储空间的利用率。</p>
<h4 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h4><p>设计散列函数的过程，实际上就是给出一个数学表达式的过程，key用过数学变换变成另外一个数</p>
<h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><p>最简单的构造方法，公式如下:</p>
<p><img src="https://img-blog.csdnimg.cn/b79e226cd66245f1923d72e317e054a8.png" referrerpolicy="no-referrer"></p>
<p>直接看例子即可:</p>
<p><img src="https://img-blog.csdnimg.cn/73a3c5d3c07c4c72a7b44971bce734f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_10,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><p>数字分析法的抽象过程就跟提取关键字一样。</p>
<p>比如身份证号，每个人的身份证号都不同，但是身份证号每个部分都有对应的结构信息，比如前六位的地址码，7-14位的出生日期码等等。再比如手机号，虽然可能存在前几位相同，但是最后的四位一般不容易重复，我们就可以取后四位作为散列地址。</p>
<p>如果还有冲突，我们可以用各式各样的办法（如左环：1234-&gt;2341,右环:1234-&gt;4123，加法:1234-&gt;12+34=46等)</p>
<p>总之，就是抽取数据中的有特殊意义的关键字。</p>
<p>这种方法对有特殊意义且分布均匀、位数较大的关键字较为适用。</p>
<h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p>这个方法就是计算。</p>
<p>假设关键字是 1234，那么它的平方就是 1522756 ，再抽取中间的3位就是 227 ，用做散列地址，再比如关键字是 4321 ，那么平方就是 18671041 ，抽取中间的3位就可以是 671 ，也可以是 710 ，用做散列地址。</p>
<p>这种方法适用于不知道关键字的分布，但是关键字位数又不大的情况。</p>
<h5 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h5><p>该方法首先将关键字从左到右分割为位数相等的几个部分，如果最后一部分位数不够就短一些，然后将这几部分叠加求和，最后按照散列表表长取后几位作为散列地址。</p>
<p>e.g:关键字为9876543210 ，散列表表长为3位，我们将它分为四组， <em>987</em>|<em>654</em>|<em>321</em>|<em>0</em> 然后将它们叠加求和 987+654+321+0=1962 ，再求后3位得到散列地址为 962</p>
<p>如果分布不够均匀，我们可以反转组然后再相加，比如仍是9876543210关键字，分为4组，我们先将654反转，然后相加987+456+321+0=1764，取后三位得764</p>
<p>这种方法适用于不知道关键字的分布，但是关键字位数又比较多的情况。</p>
<h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p>最常用的散列函数构造方法，如果我们假设散列表的表长为m，则公式如下:</p>
<p><img src="https://img-blog.csdnimg.cn/5fa0a39ba71c446f943a33c4cd8c3bc1.png" referrerpolicy="no-referrer"></p>
<p>该方法不仅可以直接使用，也可以搭配之前的几个方法一起使用，比如先折叠然后求模，先平方取中后求模。</p>
<p>使用该方法的关键在于<strong>p的选取</strong>，这会直接影响到产生的散列冲突。</p>
<p><strong>这里有一个结论，假设散列表表长为m，p可以选择小于或等于表长（接近m）的最小质数，或不包含小于20质因子的合数。</strong></p>
<h5 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h5><p>这个更简单，就是直接选一个随机数，取关键字的随机函数值为他的散列地址，即<strong>f(key) = random(key)</strong></p>
<p>该方法适用于当关键字的长度不等时。</p>
<h4 id="散列函数的构造考虑因素"><a href="#散列函数的构造考虑因素" class="headerlink" title="散列函数的构造考虑因素"></a>散列函数的构造考虑因素</h4><ol>
    <li>计算散列地址的所需时间（即计算f(key)所需要的事件）</li>
    <li>关键字的长度</li>
    <li>散列表的大小</li>
    <li>关键字的分布情况</li>
    <li>记录的查找频率</li>
</ol>


<h3 id="处理散列冲突"><a href="#处理散列冲突" class="headerlink" title="处理散列冲突"></a>处理散列冲突</h3><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>开放定址法的含义是,<strong>如果当前发生了冲突，就去寻找下一个空的散列地址，这样只要散列表足够大，我们总能够找到空闲的位置插入。</strong></p>
<p>核心公式</p>
<p><img src="https://img-blog.csdnimg.cn/ec8bdd1459a8468c8a9939c1104e834d.png" referrerpolicy="no-referrer"></p>
<p>这段公式的意思我们可以这样理解:</p>
<p>对于一组数组{10,12,14,28,26,33,40}，表长为7，哈希函数为H(key) = key % 6</p>
<p>初始状态如下</p>
<p><img src="https://img-blog.csdnimg.cn/b4a273fad13f4fbca0be3471e7bf66b7.png" referrerpolicy="no-referrer"></p>
<p>首先插入10,12,14，都不存在哈希冲突</p>
<img src="https://img-blog.csdnimg.cn/b51f264c03e5441fb92bfdfc91a69760.png" referrerpolicy="no-referrer">

<p>但是当插入H(28) = 28 % 6 = 4，这时候就会产生冲突。</p>
<p>这时候我们就可以按照公式重新计算Hi(key) = (H(key) + di) % 7 (di = 1,2,3…,m - 1)</p>
<p>首先我们H0(28) = H(28) = 4</p>
<p>所以H1(28) = (H(28) + 1) % 7 = 5,这时候发现5是空的，所以加入</p>
<p><img src="https://img-blog.csdnimg.cn/eb6baf43a807430bb951f3556cd19a24.png" referrerpolicy="no-referrer"></p>
<p>类似的，对于H(26) = 26 % 6 = 2，通过H1(26) = (H(26) + 1) % 7 = 3加入</p>
<p><img src="https://img-blog.csdnimg.cn/127db39f375449dd91750ac20774a561.png" referrerpolicy="no-referrer"></p>
<p>随后，对于H(33)，我们也可以做类似的推导:</p>
<p>H1(33) = (3 + 1) % 7 = 4,H2(33) = (3 + 2) % 7 = 5，H3(33) = (3 + 3) % 7 = 6所以加入</p>
<p><img src="https://img-blog.csdnimg.cn/1597836da02746a9b7818552144aff7c.png" referrerpolicy="no-referrer"></p>
<p>最后，对于H(40)</p>
<p>H1(40) = (4 + 1) % 7 = 5,H2(40) = (4 + 2) % 7 = 6,H3(40) = (4 + 3) % 7 = 0</p>
<p>H4(40) = (4 + 4) % 7 = 1,所以加入</p>
<p><img src="https://img-blog.csdnimg.cn/01ee1e2928f94512bee9e55a3fca3e25.png" referrerpolicy="no-referrer"></p>
<p>这种<strong>解决冲突的开放定址法称为线性探测法</strong></p>
<p><strong>要非常注意，地址序列每一次都是H(key) + di，H(key)是一个已经求得的常数。</strong></p>
<p>同时，该方法还可能导致<strong>明明不是同义词，却被迫争夺同一个地址</strong>的情况。这种现象称为<strong>堆积</strong>。</p>
<p>为了应对这种情况，有一个方法是采用<strong>二次探测法</strong>:</p>
<p><strong>增加平方运算的目的是为了不让关键字都聚集在某一块区域</strong></p>
<p>核心公式（<strong>注意f(key)为常数</strong>）:</p>
<p><img src="https://img-blog.csdnimg.cn/c16117024d99401381bdc21b2ad52e4c.png" referrerpolicy="no-referrer"></p>
<p>还有一种探测法（<strong>注意f(key)为常数</strong>）：<strong>随机探测法</strong></p>
<p><img src="https://img-blog.csdnimg.cn/4dd4fce6690a49ea9e32f65a004eb479.png" referrerpolicy="no-referrer"></p>
<h4 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h4><p>再散列函数法的核心就是事先准备好多个散列函数</p>
<p><img src="https://img-blog.csdnimg.cn/c50adaa72c1e45fba85db2db18c03da6.png" referrerpolicy="no-referrer"></p>
<p>再散列函数法通常</p>
<p>会结合探测法，构成新的方法，比如:</p>
<p><strong>线性探测再散列：同样的线性探测法的计算公式，只不过这里的 di = c∙i (⼀般取c = 1), 1≤i≤m-1，如1,2,3…</strong></p>
<p><strong>⼆次探测再散列：同样的线性探测法的计算公式，只不过这里的 di = (-1) ^(i+1) * ((i+1)/2) ^2 , 1≤i≤m/2，如1^2 ,-1^2, 2^2,-2^2,等等</strong></p>
<p>另外注意二次探测再散列如果散列地址为负数需要加上表长变为正数。</p>
<p><img src="https://img-blog.csdnimg.cn/98649dcec85d44c4bdc4229d89e7dc6c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_20,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>前面我们都是一旦产生了哈希冲突，我们就尝试换地方，但是我们可不可以不换地方呢？这就想到了链表。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HashNode</span> {</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    HashNode* next;</span><br><span class="line">}*HashMap;</span><br></pre></td></tr></tbody></table></figure>
<p>创建时用表长为m的数组创建即可</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap* H = <span class="keyword">new</span> HashMap[m];</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ac9d75b059b84c74b3d8733cdef460c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_12,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>虽然这样的想法简单且方便，但是由于是单链表的形式，就带来了一旦要查找链表就只能逐个查找的尴尬。</p>
<h4 id="公共区溢出法"><a href="#公共区溢出法" class="headerlink" title="公共区溢出法"></a>公共区溢出法</h4><p>简单来说，就是把产生了哈希冲突的数据存到别的地方</p>
<p>比如对于{12,67,56,16,25,37,22,29,15,47,48,34},H(key) = key % 12</p>
<p>可以构造如下溢出区</p>
<p><img src="https://img-blog.csdnimg.cn/6031e7313f654e8a95f70d9a74b324d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5piv5LiA5Y-q5bCP5YWU5YWU77yB,size_9,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"></p>
<p>一旦冲突的数据较多，这种方法就极其不方便了。</p>
<h3 id="散列查找（哈希查找）"><a href="#散列查找（哈希查找）" class="headerlink" title="散列查找（哈希查找）"></a>散列查找（哈希查找）</h3><p>哈希表结构及其函数实现，原理比较简单。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mod 11</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HashMap</span>{</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* elem;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitHashMap</span><span class="params">(HashMap&amp; H,<span class="type">int</span> size)</span> </span>{</span><br><span class="line">    H.size = size;</span><br><span class="line">    H.elem = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        H.elem[i] = <span class="number">65535</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> key % mod;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertHashMap</span><span class="params">(HashMap&amp; H,<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> key = <span class="built_in">Hash</span>(num);</span><br><span class="line">    <span class="keyword">while</span> (H.elem[key] != <span class="number">65535</span>) {</span><br><span class="line">        key = (key + <span class="number">1</span>) % mod;</span><br><span class="line">    }</span><br><span class="line">    H.elem[key] = num;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchHashMap</span><span class="params">(HashMap&amp; H,<span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="type">int</span> key = <span class="built_in">Hash</span>(num);</span><br><span class="line">    <span class="keyword">while</span> (H.elem[key] != num) {</span><br><span class="line">        key = (key + <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="keyword">if</span> (H.elem[key] == <span class="number">65535</span> || key == <span class="built_in">Hash</span>(num)) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="查找性能分析"><a href="#查找性能分析" class="headerlink" title="查找性能分析"></a>查找性能分析</h4><p>先考虑最理想情况的散列表，不存在散列冲突的问题，那么散列表的查找性能为O(1)</p>
<p>但是现实往往不够理想，散列冲突在所难免。因此，对于一个散列表，可以从这几个方面来考虑其查找性能。</p>
<ol>
    <li>散列函数的均匀程度:一个好的散列函数，应该能够把数据均匀分布在散列的各处，从而降低散列冲突发生的可能性</li>
    <li>散列冲突的处理:如何处理散列冲突也是评价一个散列表其性能的关键之一，最典型的是公共溢出区，当有较多的散列冲突发生时散列表性能明显下降。</li>
    <li>散列表的填装因子:定义散列表的填装因子为:填入表中的记录个数/散列表的表长，这个填装因子描述的是散列表的装满的程度。一般来说，填装因子越大，散列冲突发生的可能性越大。因此，散列表的查找性能也主要取决于填装因子。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://enthushtism.top">Enthushtism_</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://enthushtism.top/enthushtism/33cb1151.html">https://enthushtism.top/enthushtism/33cb1151.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://enthushtism.top" target="_blank">摘星崖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a><a class="post-meta__tags" href="/tags/data-structure/">data structure</a></div><div class="post_share"><div class="social-share" data-image="/img/%E6%9F%A5%E6%89%BE.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/enthushtism/ee040603.html"><img class="prev-cover" src="/img/%E5%9B%BE.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图</div></div></a></div><div class="next-post pull-right"><a href="/enthushtism/7b216a3b.html"><img class="next-cover" src="/img/%E6%A0%91.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">树</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/enthushtism/a444b428.html" title="排序"><img class="cover" src="/img/%E6%8E%92%E5%BA%8F.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">排序</div></div></a></div><div><a href="/enthushtism/ee040603.html" title="图"><img class="cover" src="/img/%E5%9B%BE.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">图</div></div></a></div><div><a href="/enthushtism/7b216a3b.html" title="树"><img class="cover" src="/img/%E6%A0%91.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">树</div></div></a></div><div><a href="/enthushtism/6534ce06.html" title="栈与队列"><img class="cover" src="/img/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">栈与队列</div></div></a></div><div><a href="/enthushtism/40f24371.html" title="线性表"><img class="cover" src="/img/%E7%BA%BF%E6%80%A7%E8%A1%A8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">线性表</div></div></a></div><div><a href="/enthushtism/942cf6c8.html" title="cpp-reference"><img class="cover" src="/img/cpp-reference.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="title">cpp-reference</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Enthushtism_</div><div class="author-info__description">多爱一点这个世界，多拥抱一下世界</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SaltyFishy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SaltyFishy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_53063591?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fab fa-codiepie"></i></a><a class="social-icon" href="https://www.luogu.com.cn/user/645540" target="_blank" title="Luogu"><i class="fa fa-comment"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个 sztuer 的稀奇古怪幻想屋~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">查找概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.2.</span> <span class="toc-text">有序表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">折半查找（二分查找）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">插值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">斐波那契查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">有序表查找小总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.3.</span> <span class="toc-text">线性索引查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">稠密索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">分块索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">倒排索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">二叉排序树（二叉搜索树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">平衡二叉树（AVL树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88B%E6%A0%91%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">多路查找树（B树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E6%A0%91"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2-3树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">2-3树的插入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">B-树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">散列表（哈希表）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">散列表的查找过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%88%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">散列函数（哈希函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">散列函数的构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">1.2.7.1.1.</span> <span class="toc-text">直接定址法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.2.7.1.2.</span> <span class="toc-text">数字分析法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="toc-number">1.2.7.1.3.</span> <span class="toc-text">平方取中法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%98%E5%8F%A0%E6%B3%95"><span class="toc-number">1.2.7.1.4.</span> <span class="toc-text">折叠法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">1.2.7.1.5.</span> <span class="toc-text">除留余数法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95"><span class="toc-number">1.2.7.1.6.</span> <span class="toc-text">随机数法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">散列函数的构造考虑因素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81"><span class="toc-number">1.2.8.</span> <span class="toc-text">处理散列冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">开放定址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%B3%95"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">再散列函数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">链地址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%B3%95"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">公共区溢出法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">1.2.9.</span> <span class="toc-text">散列查找（哈希查找）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">查找性能分析</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/enthushtism/49006407.html" title="prolist"><img src="/img/prolist.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="prolist"></a><div class="content"><a class="title" href="/enthushtism/49006407.html" title="prolist">prolist</a><time datetime="2023-05-10T09:39:20.000Z" title="发表于 2023-05-10 17:39:20">2023-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/enthushtism/942cf6c8.html" title="cpp-reference"><img src="/img/cpp-reference.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cpp-reference"></a><div class="content"><a class="title" href="/enthushtism/942cf6c8.html" title="cpp-reference">cpp-reference</a><time datetime="2023-03-15T02:22:31.000Z" title="发表于 2023-03-15 10:22:31">2023-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/enthushtism/f255ffad.html" title="docker"><img src="/img/docker.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker"></a><div class="content"><a class="title" href="/enthushtism/f255ffad.html" title="docker">docker</a><time datetime="2023-01-20T13:46:56.000Z" title="发表于 2023-01-20 21:46:56">2023-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/enthushtism/4b4dbb3.html" title="hexo-butterfly"><img src="/img/hexo-butterfly.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo-butterfly"></a><div class="content"><a class="title" href="/enthushtism/4b4dbb3.html" title="hexo-butterfly">hexo-butterfly</a><time datetime="2023-01-09T08:01:33.000Z" title="发表于 2023-01-09 16:01:33">2023-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/enthushtism/9ac1aea8.html" title="组合数"><img src="/img/%E7%BB%84%E5%90%88%E6%95%B0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="组合数"></a><div class="content"><a class="title" href="/enthushtism/9ac1aea8.html" title="组合数">组合数</a><time datetime="2023-01-09T04:21:24.000Z" title="发表于 2023-01-09 12:21:24">2023-01-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2023/1/3 - 2023 By Enthushtism_</div><div class="framework-info"><span>ICP:</span>
<a href="http://beian.miit.gov.cn/" target="_blank">粤ICP备2023028292号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'yQEOxaynnoS0xpejLnvwQGOM-gzGzoHsz',
      appKey: 'HIFfBBRsf20WHLklfma0EkX9',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="3868803653" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="线段树,稀疏表,KMP,今天不学习，明天变垃圾,树状数组,AC自动机,主席树,基环树,网络流,二分,平衡树,并查集,Dancing Link,单调栈,单调队列,分块,霍夫曼树,哈希表,可持久化,Suffix Array,Dijkstra,Floyd,Spfa(它死了),TopoSort,差分约束,Prim,Kruskal,Trie,dfs,bfs,Exgcd,高斯消元,Lucas定理,差分约束,快速幂,Tarjan,LCA,Flood Fill,A_star,双向Bfs,匈牙利算法,FFT,中国剩余定理,高精度,容斥原理,差分约束,单纯形法,负环,IDA*,矩阵,Prefix Sum,差分,树链剖分,扫描线,manacher,乘法逆元,三分,Z函数,String Hash,线性筛,莫队,裴蜀定理,线性同余方程" data-fontsize="20px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>